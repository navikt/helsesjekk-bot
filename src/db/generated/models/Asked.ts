/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Asked` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client'
import type * as $Enums from '../enums'
import type * as Prisma from '../internal/prismaNamespace'

/**
 * Model Asked
 *
 */
export type AskedModel = runtime.Types.Result.DefaultSelection<Prisma.$AskedPayload>

export type AggregateAsked = {
    _count: AskedCountAggregateOutputType | null
    _avg: AskedAvgAggregateOutputType | null
    _sum: AskedSumAggregateOutputType | null
    _min: AskedMinAggregateOutputType | null
    _max: AskedMaxAggregateOutputType | null
}

export type AskedAvgAggregateOutputType = {
    id: number | null
}

export type AskedSumAggregateOutputType = {
    id: number | null
}

export type AskedMinAggregateOutputType = {
    id: number | null
    messageTs: string | null
    teamId: string | null
    timestamp: Date | null
    revealed: boolean | null
    nagged: boolean | null
    skipped: boolean | null
}

export type AskedMaxAggregateOutputType = {
    id: number | null
    messageTs: string | null
    teamId: string | null
    timestamp: Date | null
    revealed: boolean | null
    nagged: boolean | null
    skipped: boolean | null
}

export type AskedCountAggregateOutputType = {
    id: number
    messageTs: number
    teamId: number
    timestamp: number
    questions: number
    revealed: number
    nagged: number
    skipped: number
    _all: number
}

export type AskedAvgAggregateInputType = {
    id?: true
}

export type AskedSumAggregateInputType = {
    id?: true
}

export type AskedMinAggregateInputType = {
    id?: true
    messageTs?: true
    teamId?: true
    timestamp?: true
    revealed?: true
    nagged?: true
    skipped?: true
}

export type AskedMaxAggregateInputType = {
    id?: true
    messageTs?: true
    teamId?: true
    timestamp?: true
    revealed?: true
    nagged?: true
    skipped?: true
}

export type AskedCountAggregateInputType = {
    id?: true
    messageTs?: true
    teamId?: true
    timestamp?: true
    questions?: true
    revealed?: true
    nagged?: true
    skipped?: true
    _all?: true
}

export type AskedAggregateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which Asked to aggregate.
     */
    where?: Prisma.AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Prisma.AskedOrderByWithRelationInput | Prisma.AskedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Askeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Askeds
     **/
    _count?: true | AskedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AskedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AskedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AskedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AskedMaxAggregateInputType
}

export type GetAskedAggregateType<T extends AskedAggregateArgs> = {
    [P in keyof T & keyof AggregateAsked]: P extends '_count' | 'count'
        ? T[P] extends true
            ? number
            : Prisma.GetScalarType<T[P], AggregateAsked[P]>
        : Prisma.GetScalarType<T[P], AggregateAsked[P]>
}

export type AskedGroupByArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.AskedWhereInput
    orderBy?: Prisma.AskedOrderByWithAggregationInput | Prisma.AskedOrderByWithAggregationInput[]
    by: Prisma.AskedScalarFieldEnum[] | Prisma.AskedScalarFieldEnum
    having?: Prisma.AskedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AskedCountAggregateInputType | true
    _avg?: AskedAvgAggregateInputType
    _sum?: AskedSumAggregateInputType
    _min?: AskedMinAggregateInputType
    _max?: AskedMaxAggregateInputType
}

export type AskedGroupByOutputType = {
    id: number
    messageTs: string
    teamId: string
    timestamp: Date
    questions: runtime.JsonValue
    revealed: boolean
    nagged: boolean
    skipped: boolean
    _count: AskedCountAggregateOutputType | null
    _avg: AskedAvgAggregateOutputType | null
    _sum: AskedSumAggregateOutputType | null
    _min: AskedMinAggregateOutputType | null
    _max: AskedMaxAggregateOutputType | null
}

type GetAskedGroupByPayload<T extends AskedGroupByArgs> = Prisma.PrismaPromise<
    Array<
        Prisma.PickEnumerable<AskedGroupByOutputType, T['by']> & {
            [P in keyof T & keyof AskedGroupByOutputType]: P extends '_count'
                ? T[P] extends boolean
                    ? number
                    : Prisma.GetScalarType<T[P], AskedGroupByOutputType[P]>
                : Prisma.GetScalarType<T[P], AskedGroupByOutputType[P]>
        }
    >
>

export type AskedWhereInput = {
    AND?: Prisma.AskedWhereInput | Prisma.AskedWhereInput[]
    OR?: Prisma.AskedWhereInput[]
    NOT?: Prisma.AskedWhereInput | Prisma.AskedWhereInput[]
    id?: Prisma.IntFilter<'Asked'> | number
    messageTs?: Prisma.StringFilter<'Asked'> | string
    teamId?: Prisma.StringFilter<'Asked'> | string
    timestamp?: Prisma.DateTimeFilter<'Asked'> | Date | string
    questions?: Prisma.JsonFilter<'Asked'>
    revealed?: Prisma.BoolFilter<'Asked'> | boolean
    nagged?: Prisma.BoolFilter<'Asked'> | boolean
    skipped?: Prisma.BoolFilter<'Asked'> | boolean
    team?: Prisma.XOR<Prisma.TeamScalarRelationFilter, Prisma.TeamWhereInput>
    answers?: Prisma.AnswerListRelationFilter
}

export type AskedOrderByWithRelationInput = {
    id?: Prisma.SortOrder
    messageTs?: Prisma.SortOrder
    teamId?: Prisma.SortOrder
    timestamp?: Prisma.SortOrder
    questions?: Prisma.SortOrder
    revealed?: Prisma.SortOrder
    nagged?: Prisma.SortOrder
    skipped?: Prisma.SortOrder
    team?: Prisma.TeamOrderByWithRelationInput
    answers?: Prisma.AnswerOrderByRelationAggregateInput
}

export type AskedWhereUniqueInput = Prisma.AtLeast<
    {
        id?: number
        AND?: Prisma.AskedWhereInput | Prisma.AskedWhereInput[]
        OR?: Prisma.AskedWhereInput[]
        NOT?: Prisma.AskedWhereInput | Prisma.AskedWhereInput[]
        messageTs?: Prisma.StringFilter<'Asked'> | string
        teamId?: Prisma.StringFilter<'Asked'> | string
        timestamp?: Prisma.DateTimeFilter<'Asked'> | Date | string
        questions?: Prisma.JsonFilter<'Asked'>
        revealed?: Prisma.BoolFilter<'Asked'> | boolean
        nagged?: Prisma.BoolFilter<'Asked'> | boolean
        skipped?: Prisma.BoolFilter<'Asked'> | boolean
        team?: Prisma.XOR<Prisma.TeamScalarRelationFilter, Prisma.TeamWhereInput>
        answers?: Prisma.AnswerListRelationFilter
    },
    'id'
>

export type AskedOrderByWithAggregationInput = {
    id?: Prisma.SortOrder
    messageTs?: Prisma.SortOrder
    teamId?: Prisma.SortOrder
    timestamp?: Prisma.SortOrder
    questions?: Prisma.SortOrder
    revealed?: Prisma.SortOrder
    nagged?: Prisma.SortOrder
    skipped?: Prisma.SortOrder
    _count?: Prisma.AskedCountOrderByAggregateInput
    _avg?: Prisma.AskedAvgOrderByAggregateInput
    _max?: Prisma.AskedMaxOrderByAggregateInput
    _min?: Prisma.AskedMinOrderByAggregateInput
    _sum?: Prisma.AskedSumOrderByAggregateInput
}

export type AskedScalarWhereWithAggregatesInput = {
    AND?: Prisma.AskedScalarWhereWithAggregatesInput | Prisma.AskedScalarWhereWithAggregatesInput[]
    OR?: Prisma.AskedScalarWhereWithAggregatesInput[]
    NOT?: Prisma.AskedScalarWhereWithAggregatesInput | Prisma.AskedScalarWhereWithAggregatesInput[]
    id?: Prisma.IntWithAggregatesFilter<'Asked'> | number
    messageTs?: Prisma.StringWithAggregatesFilter<'Asked'> | string
    teamId?: Prisma.StringWithAggregatesFilter<'Asked'> | string
    timestamp?: Prisma.DateTimeWithAggregatesFilter<'Asked'> | Date | string
    questions?: Prisma.JsonWithAggregatesFilter<'Asked'>
    revealed?: Prisma.BoolWithAggregatesFilter<'Asked'> | boolean
    nagged?: Prisma.BoolWithAggregatesFilter<'Asked'> | boolean
    skipped?: Prisma.BoolWithAggregatesFilter<'Asked'> | boolean
}

export type AskedCreateInput = {
    messageTs: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
    team: Prisma.TeamCreateNestedOneWithoutAskedInput
    answers?: Prisma.AnswerCreateNestedManyWithoutAskedInput
}

export type AskedUncheckedCreateInput = {
    id?: number
    messageTs: string
    teamId: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
    answers?: Prisma.AnswerUncheckedCreateNestedManyWithoutAskedInput
}

export type AskedUpdateInput = {
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
    team?: Prisma.TeamUpdateOneRequiredWithoutAskedNestedInput
    answers?: Prisma.AnswerUpdateManyWithoutAskedNestedInput
}

export type AskedUncheckedUpdateInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    teamId?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
    answers?: Prisma.AnswerUncheckedUpdateManyWithoutAskedNestedInput
}

export type AskedCreateManyInput = {
    id?: number
    messageTs: string
    teamId: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
}

export type AskedUpdateManyMutationInput = {
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type AskedUncheckedUpdateManyInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    teamId?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type AskedListRelationFilter = {
    every?: Prisma.AskedWhereInput
    some?: Prisma.AskedWhereInput
    none?: Prisma.AskedWhereInput
}

export type AskedOrderByRelationAggregateInput = {
    _count?: Prisma.SortOrder
}

export type AskedCountOrderByAggregateInput = {
    id?: Prisma.SortOrder
    messageTs?: Prisma.SortOrder
    teamId?: Prisma.SortOrder
    timestamp?: Prisma.SortOrder
    questions?: Prisma.SortOrder
    revealed?: Prisma.SortOrder
    nagged?: Prisma.SortOrder
    skipped?: Prisma.SortOrder
}

export type AskedAvgOrderByAggregateInput = {
    id?: Prisma.SortOrder
}

export type AskedMaxOrderByAggregateInput = {
    id?: Prisma.SortOrder
    messageTs?: Prisma.SortOrder
    teamId?: Prisma.SortOrder
    timestamp?: Prisma.SortOrder
    revealed?: Prisma.SortOrder
    nagged?: Prisma.SortOrder
    skipped?: Prisma.SortOrder
}

export type AskedMinOrderByAggregateInput = {
    id?: Prisma.SortOrder
    messageTs?: Prisma.SortOrder
    teamId?: Prisma.SortOrder
    timestamp?: Prisma.SortOrder
    revealed?: Prisma.SortOrder
    nagged?: Prisma.SortOrder
    skipped?: Prisma.SortOrder
}

export type AskedSumOrderByAggregateInput = {
    id?: Prisma.SortOrder
}

export type AskedScalarRelationFilter = {
    is?: Prisma.AskedWhereInput
    isNot?: Prisma.AskedWhereInput
}

export type AskedCreateNestedManyWithoutTeamInput = {
    create?:
        | Prisma.XOR<Prisma.AskedCreateWithoutTeamInput, Prisma.AskedUncheckedCreateWithoutTeamInput>
        | Prisma.AskedCreateWithoutTeamInput[]
        | Prisma.AskedUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Prisma.AskedCreateOrConnectWithoutTeamInput | Prisma.AskedCreateOrConnectWithoutTeamInput[]
    createMany?: Prisma.AskedCreateManyTeamInputEnvelope
    connect?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
}

export type AskedUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
        | Prisma.XOR<Prisma.AskedCreateWithoutTeamInput, Prisma.AskedUncheckedCreateWithoutTeamInput>
        | Prisma.AskedCreateWithoutTeamInput[]
        | Prisma.AskedUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Prisma.AskedCreateOrConnectWithoutTeamInput | Prisma.AskedCreateOrConnectWithoutTeamInput[]
    createMany?: Prisma.AskedCreateManyTeamInputEnvelope
    connect?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
}

export type AskedUpdateManyWithoutTeamNestedInput = {
    create?:
        | Prisma.XOR<Prisma.AskedCreateWithoutTeamInput, Prisma.AskedUncheckedCreateWithoutTeamInput>
        | Prisma.AskedCreateWithoutTeamInput[]
        | Prisma.AskedUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Prisma.AskedCreateOrConnectWithoutTeamInput | Prisma.AskedCreateOrConnectWithoutTeamInput[]
    upsert?: Prisma.AskedUpsertWithWhereUniqueWithoutTeamInput | Prisma.AskedUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: Prisma.AskedCreateManyTeamInputEnvelope
    set?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    disconnect?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    delete?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    connect?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    update?: Prisma.AskedUpdateWithWhereUniqueWithoutTeamInput | Prisma.AskedUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: Prisma.AskedUpdateManyWithWhereWithoutTeamInput | Prisma.AskedUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: Prisma.AskedScalarWhereInput | Prisma.AskedScalarWhereInput[]
}

export type AskedUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
        | Prisma.XOR<Prisma.AskedCreateWithoutTeamInput, Prisma.AskedUncheckedCreateWithoutTeamInput>
        | Prisma.AskedCreateWithoutTeamInput[]
        | Prisma.AskedUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Prisma.AskedCreateOrConnectWithoutTeamInput | Prisma.AskedCreateOrConnectWithoutTeamInput[]
    upsert?: Prisma.AskedUpsertWithWhereUniqueWithoutTeamInput | Prisma.AskedUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: Prisma.AskedCreateManyTeamInputEnvelope
    set?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    disconnect?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    delete?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    connect?: Prisma.AskedWhereUniqueInput | Prisma.AskedWhereUniqueInput[]
    update?: Prisma.AskedUpdateWithWhereUniqueWithoutTeamInput | Prisma.AskedUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: Prisma.AskedUpdateManyWithWhereWithoutTeamInput | Prisma.AskedUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: Prisma.AskedScalarWhereInput | Prisma.AskedScalarWhereInput[]
}

export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
}

export type AskedCreateNestedOneWithoutAnswersInput = {
    create?: Prisma.XOR<Prisma.AskedCreateWithoutAnswersInput, Prisma.AskedUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: Prisma.AskedCreateOrConnectWithoutAnswersInput
    connect?: Prisma.AskedWhereUniqueInput
}

export type AskedUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: Prisma.XOR<Prisma.AskedCreateWithoutAnswersInput, Prisma.AskedUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: Prisma.AskedCreateOrConnectWithoutAnswersInput
    upsert?: Prisma.AskedUpsertWithoutAnswersInput
    connect?: Prisma.AskedWhereUniqueInput
    update?: Prisma.XOR<
        Prisma.XOR<Prisma.AskedUpdateToOneWithWhereWithoutAnswersInput, Prisma.AskedUpdateWithoutAnswersInput>,
        Prisma.AskedUncheckedUpdateWithoutAnswersInput
    >
}

export type AskedCreateWithoutTeamInput = {
    messageTs: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
    answers?: Prisma.AnswerCreateNestedManyWithoutAskedInput
}

export type AskedUncheckedCreateWithoutTeamInput = {
    id?: number
    messageTs: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
    answers?: Prisma.AnswerUncheckedCreateNestedManyWithoutAskedInput
}

export type AskedCreateOrConnectWithoutTeamInput = {
    where: Prisma.AskedWhereUniqueInput
    create: Prisma.XOR<Prisma.AskedCreateWithoutTeamInput, Prisma.AskedUncheckedCreateWithoutTeamInput>
}

export type AskedCreateManyTeamInputEnvelope = {
    data: Prisma.AskedCreateManyTeamInput | Prisma.AskedCreateManyTeamInput[]
    skipDuplicates?: boolean
}

export type AskedUpsertWithWhereUniqueWithoutTeamInput = {
    where: Prisma.AskedWhereUniqueInput
    update: Prisma.XOR<Prisma.AskedUpdateWithoutTeamInput, Prisma.AskedUncheckedUpdateWithoutTeamInput>
    create: Prisma.XOR<Prisma.AskedCreateWithoutTeamInput, Prisma.AskedUncheckedCreateWithoutTeamInput>
}

export type AskedUpdateWithWhereUniqueWithoutTeamInput = {
    where: Prisma.AskedWhereUniqueInput
    data: Prisma.XOR<Prisma.AskedUpdateWithoutTeamInput, Prisma.AskedUncheckedUpdateWithoutTeamInput>
}

export type AskedUpdateManyWithWhereWithoutTeamInput = {
    where: Prisma.AskedScalarWhereInput
    data: Prisma.XOR<Prisma.AskedUpdateManyMutationInput, Prisma.AskedUncheckedUpdateManyWithoutTeamInput>
}

export type AskedScalarWhereInput = {
    AND?: Prisma.AskedScalarWhereInput | Prisma.AskedScalarWhereInput[]
    OR?: Prisma.AskedScalarWhereInput[]
    NOT?: Prisma.AskedScalarWhereInput | Prisma.AskedScalarWhereInput[]
    id?: Prisma.IntFilter<'Asked'> | number
    messageTs?: Prisma.StringFilter<'Asked'> | string
    teamId?: Prisma.StringFilter<'Asked'> | string
    timestamp?: Prisma.DateTimeFilter<'Asked'> | Date | string
    questions?: Prisma.JsonFilter<'Asked'>
    revealed?: Prisma.BoolFilter<'Asked'> | boolean
    nagged?: Prisma.BoolFilter<'Asked'> | boolean
    skipped?: Prisma.BoolFilter<'Asked'> | boolean
}

export type AskedCreateWithoutAnswersInput = {
    messageTs: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
    team: Prisma.TeamCreateNestedOneWithoutAskedInput
}

export type AskedUncheckedCreateWithoutAnswersInput = {
    id?: number
    messageTs: string
    teamId: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
}

export type AskedCreateOrConnectWithoutAnswersInput = {
    where: Prisma.AskedWhereUniqueInput
    create: Prisma.XOR<Prisma.AskedCreateWithoutAnswersInput, Prisma.AskedUncheckedCreateWithoutAnswersInput>
}

export type AskedUpsertWithoutAnswersInput = {
    update: Prisma.XOR<Prisma.AskedUpdateWithoutAnswersInput, Prisma.AskedUncheckedUpdateWithoutAnswersInput>
    create: Prisma.XOR<Prisma.AskedCreateWithoutAnswersInput, Prisma.AskedUncheckedCreateWithoutAnswersInput>
    where?: Prisma.AskedWhereInput
}

export type AskedUpdateToOneWithWhereWithoutAnswersInput = {
    where?: Prisma.AskedWhereInput
    data: Prisma.XOR<Prisma.AskedUpdateWithoutAnswersInput, Prisma.AskedUncheckedUpdateWithoutAnswersInput>
}

export type AskedUpdateWithoutAnswersInput = {
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
    team?: Prisma.TeamUpdateOneRequiredWithoutAskedNestedInput
}

export type AskedUncheckedUpdateWithoutAnswersInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    teamId?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type AskedCreateManyTeamInput = {
    id?: number
    messageTs: string
    timestamp: Date | string
    questions: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed: boolean
    nagged?: boolean
    skipped?: boolean
}

export type AskedUpdateWithoutTeamInput = {
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
    answers?: Prisma.AnswerUpdateManyWithoutAskedNestedInput
}

export type AskedUncheckedUpdateWithoutTeamInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
    answers?: Prisma.AnswerUncheckedUpdateManyWithoutAskedNestedInput
}

export type AskedUncheckedUpdateManyWithoutTeamInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number
    messageTs?: Prisma.StringFieldUpdateOperationsInput | string
    timestamp?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
    questions?: Prisma.JsonNullValueInput | runtime.InputJsonValue
    revealed?: Prisma.BoolFieldUpdateOperationsInput | boolean
    nagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
    skipped?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

/**
 * Count Type AskedCountOutputType
 */

export type AskedCountOutputType = {
    answers: number
}

export type AskedCountOutputTypeSelect<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    answers?: boolean | AskedCountOutputTypeCountAnswersArgs
}

/**
 * AskedCountOutputType without action
 */
export type AskedCountOutputTypeDefaultArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the AskedCountOutputType
     */
    select?: Prisma.AskedCountOutputTypeSelect<ExtArgs> | null
}

/**
 * AskedCountOutputType without action
 */
export type AskedCountOutputTypeCountAnswersArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.AnswerWhereInput
}

export type AskedSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    runtime.Types.Extensions.GetSelect<
        {
            id?: boolean
            messageTs?: boolean
            teamId?: boolean
            timestamp?: boolean
            questions?: boolean
            revealed?: boolean
            nagged?: boolean
            skipped?: boolean
            team?: boolean | Prisma.TeamDefaultArgs<ExtArgs>
            answers?: boolean | Prisma.Asked$answersArgs<ExtArgs>
            _count?: boolean | Prisma.AskedCountOutputTypeDefaultArgs<ExtArgs>
        },
        ExtArgs['result']['asked']
    >

export type AskedSelectCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean
        messageTs?: boolean
        teamId?: boolean
        timestamp?: boolean
        questions?: boolean
        revealed?: boolean
        nagged?: boolean
        skipped?: boolean
        team?: boolean | Prisma.TeamDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['asked']
>

export type AskedSelectUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean
        messageTs?: boolean
        teamId?: boolean
        timestamp?: boolean
        questions?: boolean
        revealed?: boolean
        nagged?: boolean
        skipped?: boolean
        team?: boolean | Prisma.TeamDefaultArgs<ExtArgs>
    },
    ExtArgs['result']['asked']
>

export type AskedSelectScalar = {
    id?: boolean
    messageTs?: boolean
    teamId?: boolean
    timestamp?: boolean
    questions?: boolean
    revealed?: boolean
    nagged?: boolean
    skipped?: boolean
}

export type AskedOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    runtime.Types.Extensions.GetOmit<
        'id' | 'messageTs' | 'teamId' | 'timestamp' | 'questions' | 'revealed' | 'nagged' | 'skipped',
        ExtArgs['result']['asked']
    >
export type AskedInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
    {
        team?: boolean | Prisma.TeamDefaultArgs<ExtArgs>
        answers?: boolean | Prisma.Asked$answersArgs<ExtArgs>
        _count?: boolean | Prisma.AskedCountOutputTypeDefaultArgs<ExtArgs>
    }
export type AskedIncludeCreateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    team?: boolean | Prisma.TeamDefaultArgs<ExtArgs>
}
export type AskedIncludeUpdateManyAndReturn<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    team?: boolean | Prisma.TeamDefaultArgs<ExtArgs>
}

export type $AskedPayload<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    name: 'Asked'
    objects: {
        team: Prisma.$TeamPayload<ExtArgs>
        answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            id: number
            messageTs: string
            teamId: string
            timestamp: Date
            questions: runtime.JsonValue
            revealed: boolean
            nagged: boolean
            skipped: boolean
        },
        ExtArgs['result']['asked']
    >
    composites: {}
}

export type AskedGetPayload<S extends boolean | null | undefined | AskedDefaultArgs> = runtime.Types.Result.GetResult<
    Prisma.$AskedPayload,
    S
>

export type AskedCountArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<AskedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AskedCountAggregateInputType | true
}

export interface AskedDelegate<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asked']; meta: { name: 'Asked' } }
    /**
     * Find zero or one Asked that matches the filter.
     * @param {AskedFindUniqueArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AskedFindUniqueArgs>(
        args: Prisma.SelectSubset<T, AskedFindUniqueArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Find one Asked that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AskedFindUniqueOrThrowArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AskedFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<T, AskedFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Find the first Asked that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedFindFirstArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AskedFindFirstArgs>(
        args?: Prisma.SelectSubset<T, AskedFindFirstArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Find the first Asked that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedFindFirstOrThrowArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AskedFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<T, AskedFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Find zero or more Askeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Askeds
     * const askeds = await prisma.asked.findMany()
     *
     * // Get first 10 Askeds
     * const askeds = await prisma.asked.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const askedWithIdOnly = await prisma.asked.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AskedFindManyArgs>(
        args?: Prisma.SelectSubset<T, AskedFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >

    /**
     * Create a Asked.
     * @param {AskedCreateArgs} args - Arguments to create a Asked.
     * @example
     * // Create one Asked
     * const Asked = await prisma.asked.create({
     *   data: {
     *     // ... data to create a Asked
     *   }
     * })
     *
     */
    create<T extends AskedCreateArgs>(
        args: Prisma.SelectSubset<T, AskedCreateArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Create many Askeds.
     * @param {AskedCreateManyArgs} args - Arguments to create many Askeds.
     * @example
     * // Create many Askeds
     * const asked = await prisma.asked.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AskedCreateManyArgs>(
        args?: Prisma.SelectSubset<T, AskedCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>

    /**
     * Create many Askeds and returns the data saved in the database.
     * @param {AskedCreateManyAndReturnArgs} args - Arguments to create many Askeds.
     * @example
     * // Create many Askeds
     * const asked = await prisma.asked.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Askeds and only return the `id`
     * const askedWithIdOnly = await prisma.asked.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AskedCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<T, AskedCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Delete a Asked.
     * @param {AskedDeleteArgs} args - Arguments to delete one Asked.
     * @example
     * // Delete one Asked
     * const Asked = await prisma.asked.delete({
     *   where: {
     *     // ... filter to delete one Asked
     *   }
     * })
     *
     */
    delete<T extends AskedDeleteArgs>(
        args: Prisma.SelectSubset<T, AskedDeleteArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Update one Asked.
     * @param {AskedUpdateArgs} args - Arguments to update one Asked.
     * @example
     * // Update one Asked
     * const asked = await prisma.asked.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AskedUpdateArgs>(
        args: Prisma.SelectSubset<T, AskedUpdateArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Delete zero or more Askeds.
     * @param {AskedDeleteManyArgs} args - Arguments to filter Askeds to delete.
     * @example
     * // Delete a few Askeds
     * const { count } = await prisma.asked.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AskedDeleteManyArgs>(
        args?: Prisma.SelectSubset<T, AskedDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>

    /**
     * Update zero or more Askeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Askeds
     * const asked = await prisma.asked.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AskedUpdateManyArgs>(
        args: Prisma.SelectSubset<T, AskedUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>

    /**
     * Update zero or more Askeds and returns the data updated in the database.
     * @param {AskedUpdateManyAndReturnArgs} args - Arguments to update many Askeds.
     * @example
     * // Update many Askeds
     * const asked = await prisma.asked.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Askeds and only return the `id`
     * const askedWithIdOnly = await prisma.asked.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AskedUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<T, AskedUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >

    /**
     * Create or update one Asked.
     * @param {AskedUpsertArgs} args - Arguments to update or create a Asked.
     * @example
     * // Update or create a Asked
     * const asked = await prisma.asked.upsert({
     *   create: {
     *     // ... data to create a Asked
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asked we want to update
     *   }
     * })
     */
    upsert<T extends AskedUpsertArgs>(
        args: Prisma.SelectSubset<T, AskedUpsertArgs<ExtArgs>>,
    ): Prisma.Prisma__AskedClient<
        runtime.Types.Result.GetResult<Prisma.$AskedPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
        never,
        ExtArgs,
        GlobalOmitOptions
    >

    /**
     * Count the number of Askeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedCountArgs} args - Arguments to filter Askeds to count.
     * @example
     * // Count the number of Askeds
     * const count = await prisma.asked.count({
     *   where: {
     *     // ... the filter for the Askeds we want to count
     *   }
     * })
     **/
    count<T extends AskedCountArgs>(
        args?: Prisma.Subset<T, AskedCountArgs>,
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<'select', any>
            ? T['select'] extends true
                ? number
                : Prisma.GetScalarType<T['select'], AskedCountAggregateOutputType>
            : number
    >

    /**
     * Allows you to perform aggregations operations on a Asked.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AskedAggregateArgs>(
        args: Prisma.Subset<T, AskedAggregateArgs>,
    ): Prisma.PrismaPromise<GetAskedAggregateType<T>>

    /**
     * Group by Asked.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends AskedGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
            Prisma.Extends<'skip', Prisma.Keys<T>>,
            Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
            ? { orderBy: AskedGroupByArgs['orderBy'] }
            : { orderBy?: AskedGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
            ? `Error: "by" must not be empty.`
            : HavingValid extends Prisma.False
              ? {
                    [P in HavingFields]: P extends ByFields
                        ? never
                        : P extends string
                          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                          : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                }[HavingFields]
              : 'take' extends Prisma.Keys<T>
                ? 'orderBy' extends Prisma.Keys<T>
                    ? ByValid extends Prisma.True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
                    : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Prisma.Keys<T>
                  ? 'orderBy' extends Prisma.Keys<T>
                      ? ByValid extends Prisma.True
                          ? {}
                          : {
                                [P in OrderFields]: P extends ByFields
                                    ? never
                                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                            }[OrderFields]
                      : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends Prisma.True
                    ? {}
                    : {
                          [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                      }[OrderFields],
    >(
        args: Prisma.SubsetIntersection<T, AskedGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetAskedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the Asked model
     */
    readonly fields: AskedFieldRefs
}

/**
 * The delegate class that acts as a "Promise-like" for Asked.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AskedClient<
    T,
    Null = never,
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    team<T extends Prisma.TeamDefaultArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.TeamDefaultArgs<ExtArgs>>,
    ): Prisma.Prisma__TeamClient<
        runtime.Types.Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
        Null,
        ExtArgs,
        GlobalOmitOptions
    >
    answers<T extends Prisma.Asked$answersArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.Asked$answersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): runtime.Types.Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}

/**
 * Fields of the Asked model
 */
export interface AskedFieldRefs {
    readonly id: Prisma.FieldRef<'Asked', 'Int'>
    readonly messageTs: Prisma.FieldRef<'Asked', 'String'>
    readonly teamId: Prisma.FieldRef<'Asked', 'String'>
    readonly timestamp: Prisma.FieldRef<'Asked', 'DateTime'>
    readonly questions: Prisma.FieldRef<'Asked', 'Json'>
    readonly revealed: Prisma.FieldRef<'Asked', 'Boolean'>
    readonly nagged: Prisma.FieldRef<'Asked', 'Boolean'>
    readonly skipped: Prisma.FieldRef<'Asked', 'Boolean'>
}

// Custom InputTypes
/**
 * Asked findUnique
 */
export type AskedFindUniqueArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where: Prisma.AskedWhereUniqueInput
}

/**
 * Asked findUniqueOrThrow
 */
export type AskedFindUniqueOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where: Prisma.AskedWhereUniqueInput
}

/**
 * Asked findFirst
 */
export type AskedFindFirstArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where?: Prisma.AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Prisma.AskedOrderByWithRelationInput | Prisma.AskedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Askeds.
     */
    cursor?: Prisma.AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Askeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Askeds.
     */
    distinct?: Prisma.AskedScalarFieldEnum | Prisma.AskedScalarFieldEnum[]
}

/**
 * Asked findFirstOrThrow
 */
export type AskedFindFirstOrThrowArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where?: Prisma.AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Prisma.AskedOrderByWithRelationInput | Prisma.AskedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Askeds.
     */
    cursor?: Prisma.AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Askeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Askeds.
     */
    distinct?: Prisma.AskedScalarFieldEnum | Prisma.AskedScalarFieldEnum[]
}

/**
 * Asked findMany
 */
export type AskedFindManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * Filter, which Askeds to fetch.
     */
    where?: Prisma.AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Prisma.AskedOrderByWithRelationInput | Prisma.AskedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Askeds.
     */
    cursor?: Prisma.AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Askeds.
     */
    skip?: number
    distinct?: Prisma.AskedScalarFieldEnum | Prisma.AskedScalarFieldEnum[]
}

/**
 * Asked create
 */
export type AskedCreateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * The data needed to create a Asked.
     */
    data: Prisma.XOR<Prisma.AskedCreateInput, Prisma.AskedUncheckedCreateInput>
}

/**
 * Asked createMany
 */
export type AskedCreateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to create many Askeds.
     */
    data: Prisma.AskedCreateManyInput | Prisma.AskedCreateManyInput[]
    skipDuplicates?: boolean
}

/**
 * Asked createManyAndReturn
 */
export type AskedCreateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * The data used to create many Askeds.
     */
    data: Prisma.AskedCreateManyInput | Prisma.AskedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Asked update
 */
export type AskedUpdateArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * The data needed to update a Asked.
     */
    data: Prisma.XOR<Prisma.AskedUpdateInput, Prisma.AskedUncheckedUpdateInput>
    /**
     * Choose, which Asked to update.
     */
    where: Prisma.AskedWhereUniqueInput
}

/**
 * Asked updateMany
 */
export type AskedUpdateManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to update Askeds.
     */
    data: Prisma.XOR<Prisma.AskedUpdateManyMutationInput, Prisma.AskedUncheckedUpdateManyInput>
    /**
     * Filter which Askeds to update
     */
    where?: Prisma.AskedWhereInput
    /**
     * Limit how many Askeds to update.
     */
    limit?: number
}

/**
 * Asked updateManyAndReturn
 */
export type AskedUpdateManyAndReturnArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * The data used to update Askeds.
     */
    data: Prisma.XOR<Prisma.AskedUpdateManyMutationInput, Prisma.AskedUncheckedUpdateManyInput>
    /**
     * Filter which Askeds to update
     */
    where?: Prisma.AskedWhereInput
    /**
     * Limit how many Askeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Asked upsert
 */
export type AskedUpsertArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * The filter to search for the Asked to update in case it exists.
     */
    where: Prisma.AskedWhereUniqueInput
    /**
     * In case the Asked found by the `where` argument doesn't exist, create a new Asked with this data.
     */
    create: Prisma.XOR<Prisma.AskedCreateInput, Prisma.AskedUncheckedCreateInput>
    /**
     * In case the Asked was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<Prisma.AskedUpdateInput, Prisma.AskedUncheckedUpdateInput>
}

/**
 * Asked delete
 */
export type AskedDeleteArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
    /**
     * Filter which Asked to delete.
     */
    where: Prisma.AskedWhereUniqueInput
}

/**
 * Asked deleteMany
 */
export type AskedDeleteManyArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which Askeds to delete
     */
    where?: Prisma.AskedWhereInput
    /**
     * Limit how many Askeds to delete.
     */
    limit?: number
}

/**
 * Asked.answers
 */
export type Asked$answersArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: Prisma.AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: Prisma.AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AnswerInclude<ExtArgs> | null
    where?: Prisma.AnswerWhereInput
    orderBy?: Prisma.AnswerOrderByWithRelationInput | Prisma.AnswerOrderByWithRelationInput[]
    cursor?: Prisma.AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Prisma.AnswerScalarFieldEnum | Prisma.AnswerScalarFieldEnum[]
}

/**
 * Asked without action
 */
export type AskedDefaultArgs<
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: Prisma.AskedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asked
     */
    omit?: Prisma.AskedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.AskedInclude<ExtArgs> | null
}
